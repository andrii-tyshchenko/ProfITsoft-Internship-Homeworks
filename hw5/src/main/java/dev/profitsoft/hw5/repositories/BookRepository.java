package dev.profitsoft.hw5.repositories;

import dev.profitsoft.hw5.dtos.BookQueryDto;
import dev.profitsoft.hw5.entities.Book;
import dev.profitsoft.hw5.repositories.mappers.BookRowMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Repository for CRUD-operations with Book entities.
 */
@Repository
public class BookRepository {
    private final JdbcTemplate jdbcTemplate;
    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    @Autowired
    public BookRepository(JdbcTemplate jdbcTemplate, NamedParameterJdbcTemplate namedParameterJdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        this.namedParameterJdbcTemplate = namedParameterJdbcTemplate;
    }

    /**
     * Inserts information from a given Book entity to a database.
     * @param book entity whose information should be inserted to a database
     * @return id generated by the database for an inserted row
     */
    public Integer save(Book book) {
        SimpleJdbcInsert insertBook = new SimpleJdbcInsert(jdbcTemplate)
                .withTableName("books")
                .usingGeneratedKeyColumns("id");

        Map<String, Object> params = new HashMap<>();
        params.put("title", book.getTitle());
        params.put("author", book.getAuthor());
        params.put("publisher_id", book.getPublisher().getId());
        params.put("isbn", book.getIsbn());
        params.put("publishing_year", book.getPublishingYear().getValue());

        return insertBook.executeAndReturnKey(params).intValue();
        /*
        This way of saving was chosen because H2 database (which is used for tests)
        doesn't support RETURNING id feature.
        Instead of SimpleJdbcInsert I would like to use RETURNING id:

        String sqlQuery = """
                INSERT INTO books (title, author, publisher_id, isbn, publishing_year)
                VALUES (:title, :author, :publisher_id, :isbn, :publishing_year)
                RETURNING id;
                """;

         // add params to map

         return namedParameterJdbcTemplate.queryForObject(sqlQuery, params, Integer.class);
         */
    }

    /**
     * Returns {@code Book} entity from a database with given id.
     * @param id value of a book's id, which should be returned
     * @return {@code Optional} object, which contains Book entity with given id,
     * or null, if such value were not found in the database
     */
    public Optional<Book> getById(int id) {
        String sqlQuery = """
                SELECT b.id AS book_id, title AS book_title, author AS book_author, isbn AS book_isbn, 
                       publishing_year AS book_publishing_year, publisher_id, p.name AS publisher_name, 
                       c.id AS country_id, c.name AS country_name, c.iso_code AS country_iso_code
                FROM books b
                     LEFT JOIN publishers p ON b.publisher_id = p.id
                     LEFT JOIN countries c ON p.country_id = c.id
                WHERE b.id = :id;
                """;

        Map<String, Integer> params = Map.of("id", id);

        List<Book> books = namedParameterJdbcTemplate.query(sqlQuery, params, new BookRowMapper());

        return Optional.ofNullable(books.isEmpty() ? null : books.get(0));
    }


    /**
     * Updates values in a database for an entity with a given id.
     * New values are represented in a given {@code Book} object.
     * @param id value of a book's id, which should be updated
     * @param book contains new values, which should be saved instead of the old ones
     */
    public void update(int id, Book book) {
        String sqlQuery = """
                UPDATE books
                SET title = :title, author = :author, publisher_id = :publisher_id, 
                    isbn = :isbn, publishing_year = :publishing_year
                WHERE id = :id;
                """;

        Map<String, Object> params = new HashMap<>();
        params.put("title", book.getTitle());
        params.put("author", book.getAuthor());
        params.put("publisher_id", book.getPublisher().getId());
        params.put("isbn", book.getIsbn());
        params.put("publishing_year", book.getPublishingYear().getValue());
        params.put("id", id);

        namedParameterJdbcTemplate.update(sqlQuery, params);
    }

    /**
     * Deletes from a database an entity with given id.
     * @param id value of a book's id, which should be deleted
     * @return true if deletion was successful
     */
    public boolean delete(int id) {
        String sqlQuery = """
                DELETE FROM books
                WHERE id = :id;
                """;

        Map<String, Integer> params = Map.of("id", id);

        return namedParameterJdbcTemplate.update(sqlQuery, params) > 0;
    }

    /**
     * Deletes all entities from a database.
     */
    public void deleteAll() {
        String sqlQuery = "DELETE FROM books;";

        jdbcTemplate.update(sqlQuery);
    }

    /**
     * Returns list of books from a database, that match requirements of a given query.
     * @param query object, which fields' values are the parameters for the search query
     * @return list of books from a database, matching query's requirements
     */
    public List<Book> search(BookQueryDto query) {
        String sqlQuery = """
                SELECT b.id AS book_id, title AS book_title, author AS book_author, isbn AS book_isbn,
                       publisher_id, p.name AS publisher_name, publishing_year AS book_publishing_year,
                       c.id AS country_id, c.name AS country_name, iso_code AS country_iso_code
                FROM books b
                     LEFT JOIN publishers p on b.publisher_id = p.id
                     LEFT JOIN countries c on p.country_id = c.id
                WHERE author = :author AND publishing_year = :publishing_year
                ORDER BY b.id, author, title
                LIMIT :limit
                OFFSET :offset;
                """;

        Map<String, Object> params = new HashMap<>();
        params.put("author", query.getAuthor());
        params.put("publishing_year", query.getPublishingYear().getValue());
        params.put("limit", query.getSize());
        params.put("offset", query.getFrom());

        return namedParameterJdbcTemplate.query(sqlQuery, params, new BookRowMapper());
    }

    /**
     * Checks if a book with given id exists in a database.
     * @param id value of a book's id, which should be checked
     * @return true if the book with given id exists in the database
     */
    public Boolean existsWithId(int id) {
        String sqlQuery = """
                SELECT COUNT(id) > 0
                FROM books
                WHERE id = :id;
                """;

        Map<String, Integer> params = Map.of("id", id);

        return namedParameterJdbcTemplate.queryForObject(sqlQuery, params, Boolean.class);
    }
}